# 浏览器渲染原理

当网络线程拿到 HTML 文档后，会产生一个渲染任务，将其添加到渲染主线程的消息队列中。

在事件循环的作用下，渲染主线程从消息队列中取出渲染任务，开始渲染流程。

![image-20240619202021468.png](%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86%20911c283bc3c643be9ecfff248b135d31/0cc2483b-6216-46cd-b0a9-7d228a2531e4.png)

## **渲染流水线**

![Untitled](%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86%20911c283bc3c643be9ecfff248b135d31/Untitled.png)

### **1. HTML 解析 (parse)**

渲染的第一步是解析 HTML。

解析过程中遇到 CSS 就解析 CSS，遇到 JS 就执行 JS。为了提高解析效率，浏览器会在解析前，开启一个**预解析线程**，率先下载 HTML 中的外部 CSS 文件和 JS 文件。

如果遇到 `link`元素，此时外部 CSS 还没有被加载解析好， **主线程不会等待**，而是继续解析后续的 HTML。这是因为加载和解析外部 CSS 是在预解析线程中进行的。这就是 CSS 不会阻塞 HTML 解析 的根本原因。

如果遇到 `script` 元素，会停止解析 HTML，**转而等待 JS 下载好**，并将全局代码解析执行完毕后，才会继续解析 HTML。这是因为在 JS 执行的过程中有可能会操作当前 DOM 树，所以 DOM 树的生成必须暂停。这就是 JS会阻塞 HTML 解析 的根本原因。

上述完成后，会生成 **DOM 树和 CSSOM 树**。浏览器的默认样式、内部样式、外部样式、内联样式均会包含在 CSSOM 树中。

![Untitled](%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86%20911c283bc3c643be9ecfff248b135d31/Untitled%201.png)

![Untitled](%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86%20911c283bc3c643be9ecfff248b135d31/Untitled%202.png)

![Untitled](%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86%20911c283bc3c643be9ecfff248b135d31/Untitled%203.png)

### **2. 样式计算 (style)**

渲染的下一步是样式计算。

主线程会遍历 DOM 树，为树中每个节点计算出他的最终样式，称为  `Computed Style`。

在这一过程中，很多相对单位会转化成绝对单位，如 `red` 变成 `rgb(255, 0, 0)`，`em` 变成 `px`。

这一步完成后，会得到一个带有样式的 DOM 树。

### **3. 布局 (Layout)**

接下来是布局，布局完成后会得到布局树。

布局阶段会遍历 DOM 树，计算每个节点的几何信息（尺寸和位置）。例如节点的宽高、相对于 [包含块] 的位置。

大部分时候，布局树 与  DOM 树并非一一对应。

例如：`display: none`的节点没有几何信息，因此不会生成到布局树。又如 伪元素 不在 DOM 树中，但它们拥有几何信息，会被生成到布局树中。

![Untitled](%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86%20911c283bc3c643be9ecfff248b135d31/Untitled%204.png)

### **4. 分层 (Layer)**

下一步是分层。

主线程会使用一套复杂的策略对整个布局树进行分层。

分层的好处在于，仅对变化的层进行重绘等后续处理，从而提升效率。

滚动条、**堆叠上下文**、transform、opacity 等都会对层级产生一定的影响，但**最终是否会被分层是由浏览器决定的**。也可以通过 `will-change` 属性更大程度地影响分层的结果。

### **5. 绘制 (Paint)**

下一步是绘制。

主线程会为每个层产生单独的绘制**指令集**，用于描述这一层的内容如何画出来。

![Untitled](%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86%20911c283bc3c643be9ecfff248b135d31/Untitled%205.png)

### **6. 分块 (Tiling)**

完成绘制后，主线程将每个图层的绘制信息交给**合成线程**，剩下的任务交由合成线程完成。

合成线程首先对每个图层进行分块，将其划分为更小的区域。

合成线程会从**线程池**中拿取多个线程来完成分块工作。

![Untitled](%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86%20911c283bc3c643be9ecfff248b135d31/Untitled%206.png)

### **7. 光栅化 (Raster)**

分块完成后，进入光栅化阶段。

合成线程会将块信息交给 GPU 进程，并启用硬件加速迅速完成光栅化。

GPU 进程会开启多个线程来完成光栅化，并优先处理靠近视口的分块。

光栅化的结果就是一个一个的位图。

![Untitled](%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86%20911c283bc3c643be9ecfff248b135d31/Untitled%207.png)

![Untitled](%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86%20911c283bc3c643be9ecfff248b135d31/Untitled%208.png)

### **8. 画 (Draw)**

最后的阶段就是 画。

合成线程拿到每一层每块的位图后，生成一个一个的 「 指引 (quad) 」信息。

指引会标出每个位图在屏幕中的位置，以及会考虑到旋转、缩放等变形。

**变形发生在合成线程，与渲染主线程无关，这也就是 `transform` 为什么性能好的本质原因。**

合成线程会把 quad 交给 GUP 进程，由 GUP 进程产生系统调用，提交给 GUP 硬件，完成最终的屏幕成像。

![Untitled](%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86%20911c283bc3c643be9ecfff248b135d31/Untitled%209.png)

## **面试题**

### **1. 什么是重排 reflow**

reflow 的本质就是根据 CSSOM 的变化重新计算 layout 树。

为了避免连续的多次修改导致布局树反复重新计算，浏览器会合并这些操作，当 JS 全部执行完毕后再统一计算，因此，改动属性造成的 reflow 是异步的。

![Untitled](%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E5%8E%9F%E7%90%86%20911c283bc3c643be9ecfff248b135d31/Untitled%2010.png)

### **2. 什么是重绘 repaint**