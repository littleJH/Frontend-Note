# 面试题

掘金社区：

- [历时一个月，2.6W字！50+Vue经典面试题源码级详解，你值得收藏！](https://juejin.cn/post/7097067108663558151)
- [又一个月，1.5W字！50+Vue经典面试题源码级详解，完结篇！](https://juejin.cn/post/7115055320913117220)

## 逻辑复用

### 组合式函数 ( useXXX )

**有状态** 的逻辑复用。区别于 ”lodash” 等无状态逻辑库。

- 以 “use” 开头
- 通过 ref 声明响应式状态
    - 为什么不用 reactive ？
        
        ```jsx
        const useMouse = () => {
        	/*...*/
        	// x , y 是两个 ref
        	return { x, y }
        }
        
        const { x, y } = useMouse()
        ```
        
        reactive 的解构会丢失响应性！
        
- 输入参数：依赖 ref 或 getter 的响应性， 非响应性的原始值：`toValue` 工具函数处理参数

```jsx
export function toValue<T>(source: MaybeRefOrGetter<T> | ComputedRef<T>): T {
  return isFunction(source) ? source() : unref(source)
}

export function unref<T>(ref: MaybeRef<T> | ComputedRef<T>): T {
  return isRef(ref) ? ref.value : ref
}
```

- 只能在 `<script setup>`或 `setup`函数中同步调用
    - 为什么？
        
        确定当前活跃的组件实例上下文！
        
        - 将生命周期钩子注册到当前组件实例上。
        - 将计算属性、侦听器注册到当前组件示例上，以便组件卸载时停止监听，避免内存泄漏。

`useFetch` 示例：

```jsx
export const useFetch = (url) => {
	const data = ref(null)
	const error = ref(null)
	
	const fetchData = () => {
		fetch((toValue(url))
			.then(res => res.json())
			.then(res => (data.value = res.res))
			.catch(err => (error.value = err))
	}
	
	watchEffect(() => {
		fetchData()
	})
	
	return { data, error }
}
```

### 自定义指令

定义：复用涉及**普通元素**的底层 DOM 访问的逻辑。

注册：

- 未使用 setup语法糖：directives
    
    ```jsx
    export default {
    	setup() {
    		/*...*/
    	}, 
    	directives: {
    		focus: {
    			/*...*/
    		}
    	}
    }
    ```
    
- setup 语法糖
    
    ```jsx
    <script setup>
    	const vFocus = {
    		mounted: (el) => el.focus()
    	}
    </script>
    
    <template>
    	// 当input被插入到 DOM 后，会自动聚焦
    	<input v-focus />
    </template>
    ```
    
- 全局注册
    
    ```jsx
    const app = createApp({})
    
    app.directive("focus", {
    	/*...*/
    })
    ```
    

特点：

- 不仅可以在页面加载完成后的对应的指令钩子中生效，还可以在**元素动态插入**后生效。

简化形式：仅需要在 `mounted` 和 `updated` 上生效的行为

```jsx
<div v-color="color"></div>

app.directive("color", (el, binding) => {
	el.style.color = binding.value
})
```

注意：不推荐在 组件 上使用自定义指令，尤其是当组件有多个根节点的情况，会报错。

指令钩子：

```jsx
const myDirective = {
  // 在绑定元素的 attribute 前
  // 或事件监听器应用前调用
  created(el, binding, vnode) {
    // 下面会介绍各个参数的细节
  },
  // 在元素被插入到 DOM 前调用
  beforeMount(el, binding, vnode) {},
  // 在绑定元素的父组件
  // 及他自己的所有子节点都挂载完成后调用
  mounted(el, binding, vnode) {},
  // 绑定元素的父组件更新前调用
  beforeUpdate(el, binding, vnode, prevVnode) {},
  // 在绑定元素的父组件
  // 及他自己的所有子节点都更新后调用
  updated(el, binding, vnode, prevVnode) {},
  // 绑定元素的父组件卸载前调用
  beforeUnmount(el, binding, vnode) {},
  // 绑定元素的父组件卸载后调用
  unmounted(el, binding, vnode) {}
}

el：指令绑定到的元素。这可以用于直接操作 DOM。

binding：一个对象，包含以下属性。

value：传递给指令的值。例如在 v-my-directive="1 + 1" 中，值是 2。
oldValue：之前的值，仅在 beforeUpdate 和 updated 中可用。无论值是否更改，它都可用。
arg：传递给指令的参数 (如果有的话)。例如在 v-my-directive:foo 中，参数是 "foo"。
modifiers：一个包含修饰符的对象 (如果有的话)。例如在 v-my-directive.foo.bar 中，修饰符对象是 { foo: true, bar: true }。
instance：使用该指令的组件实例。
dir：指令的定义对象。
vnode：代表绑定元素的底层 VNode。

prevVnode：代表之前的渲染中指令所绑定元素的 VNode。仅在 beforeUpdate 和 updated 钩子中可用。
```

### 插件

### app 组件实例的功能

1. 注册全局组件
    
    ```jsx
    app.component("MyComponent", MyComponent)
    ```
    
2. 注册全局指令
    
    ```jsx
    app.directive("myDire", { /*...*/ })
    ```
    
3. 设置全局属性
    
    ```jsx
    app.config.globalProperties.$myGlobalProperty = "hello"
    ```
    
4. 注册全局混入
    
    ```jsx
    app.mixin({
      created() {
        console.log('A component was created!')
      }
    })
    ```
    
5. 提供依赖注入
    
    ```jsx
    app.provide("myProvide", "hello")
    ```
    
6. 使用插件
    
    ```jsx
    app.use(myPlugin)
    ```
    
7. 挂载应用
    
    ```jsx
    app.mount("#app")
    ```