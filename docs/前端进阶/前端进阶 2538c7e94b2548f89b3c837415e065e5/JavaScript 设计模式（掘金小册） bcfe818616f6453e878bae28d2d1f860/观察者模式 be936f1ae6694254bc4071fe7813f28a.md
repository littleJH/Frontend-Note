# 观察者模式

又叫：发布订阅模式

两个关键角色：发布者，订阅者

### 发布订阅的简单实现

```jsx
// 发布者
class Publisher {
  constructor(state) {
    // 状态
    this.state = state
    // 订阅者集合
    this.observers = new Set()
  }

	// 获取状态
  getState() {
    return this.state
  }

	// 更新状态
  setState(state) {
    console.log('🚀 ~ Publisher ~ setState ~ state:', state)
    this.state = state
    // 通知订阅者
    this.notify()
  }

	// 添加订阅者
  addObserver(observer) {
    observer && Array.isArray(observer) ? observer.map((item) => this.observers.add(observer)) : this.observers.add(observer)
  }

	// 移除订阅者
  removeObserver(observer) {
    this.observers.delete(observer)
  }

	// 通知订阅者
  notify() {
    console.log('🚀 ~ Publisher ~ notify')
    // 遍历订阅者集合，调用订阅者的更新方法，传入新的状态
    this.observers.forEach((observer) => observer.update(this.state))
  }
}

// 订阅者
class Observer {
  constructor() {}

  update(state) {
    console.log('🚀 ~ observer ~ update ~ state:', state)
  }
}

const observer = new Observer()
const observer1 = new Observer()
const publisher = new Publisher({
  name: 'zjh',
})
publisher.addObserver([observer, observer1])
publisher.setState({
  name: 'lcl',
})
```

### `EventBus` 的实现

需要实现的方法：

- `on(name, cb)`
- `emit(name, val)`
- `off(name, cb)`
- `once(name, cb)`

```jsx
class EventBus {
  constructor() {
    this.handlerMap = new Map()
  }

  /**
   * 安装事件监听器
   *
   * @param eventName {String} 事件名
   * @param callback {Function} 事件回调
   */
  on(eventName, callback) {
    const map = this.handlerMap
    if (!map.get(eventName)) {
      map.set(eventName, new Set())
    }
    map.get(eventName).add(callback)
  }

  /**
   * 触发目标事件
   *
   * @param eventName {Stirng} 事件名
   * @param value { Any } 需要传递给监听器的参数
   */
  emit(eventName, value) {
    this.handlerMap.get(eventName) && this.handlerMap.get(eventName).forEach((cb) => cb(value))
  }

  /**
   * 移除指定事件的指定回调
   *
   * @param eventName {String} 事件名
   * @param callback {Function} 指定要删除的事件的回调
   */
  off(eventName, callback) {
    console.log('🚀 ~ EventBus ~ off ~ eventName, callback:', eventName, callback)
    this.handlerMap.get(eventName).delete(callback)
  }

  /**
   * 为事件注册单次监听器
   * 触发一次后自动删除
   *
   * @param eventName {String} 事件名
   * @param callback {Fcuntin} 事件回调
   */
  once(eventName, callback) {
    this.on(eventName, (val) => {
      callback(val)
      this.off(eventName, callback)
    })
  }
}

const bus = new EventBus()

bus.on('myevent', (val) => {
  console.log('🚀 ~ bus.on ~ val:', val)
})

setTimeout(() => {
  Promise.resolve(() => {
    bus.emit('myevent', {
      time: new Date().toString(),
    })
  }).then(() => {
    bus.off('myevent')
  })
}, 1000)

bus.once('onceEvent', (val) => {
  console.log('🚀 ~ bus.once ~ val:', val)
})

setTimeout(() => {
  bus.emit('onceEvent', {
    once: true,
  })
}, 2000)
```