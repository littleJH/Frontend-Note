# 策略模式

> 定义一系列算法，并把它们单独封装起来，并使他们可以相互替换。
> 

- 算法提取
- 算法封装
- 分发优化

### 改造 `if-else`

- 原始逻辑
    
    ```jsx
    // 处理预热价
    function prePrice(originPrice) {
      if(originPrice >= 100) {
        return originPrice - 20
      } 
      return originPrice * 0.9
    }
    
    // 处理大促价
    function onSalePrice(originPrice) {
      if(originPrice >= 100) {
        return originPrice - 30
      } 
      return originPrice * 0.8
    }
    
    // 处理返场价
    function backPrice(originPrice) {
      if(originPrice >= 200) {
        return originPrice - 50
      }
      return originPrice
    }
    
    // 处理尝鲜价
    function freshPrice(originPrice) {
      return originPrice * 0.5
    }
    
    // 处理新人价
    function newUserPrice(originPrice) {
      if(originPrice >= 100) {
        return originPrice - 50
      }
      return originPrice
    }
    
    function askPrice(tag, originPrice) {
      // 处理预热价
      if(tag === 'pre') {
        return prePrice(originPrice)
      }
      // 处理大促价
      if(tag === 'onSale') {
        return onSalePrice(originPrice)
      }
    
      // 处理返场价
      if(tag === 'back') {
        return backPrice(originPrice)
      }
    
      // 处理尝鲜价
      if(tag === 'fresh') {
         return freshPrice(originPrice)
      }
      
      // 处理新人价
      if(tag === 'newUser') {
         return newUserPrice(originPrice)
      }
    }
    
    ```
    

大量的 `if-else` 的目的是什么？完成 tag 与 method 的映射。

有没有什么既能明确映射关系，又能不违反开闭原则的呢？

**答案就是对象映射！**

将 tag 与 method 的映射关系收敛进一个对象

```jsx
// 定义一个询价处理器对象
const priceProcessor = {
  pre(originPrice) {
    if (originPrice >= 100) {
      return originPrice - 20;
    }
    return originPrice * 0.9;
  },
  onSale(originPrice) {
    if (originPrice >= 100) {
      return originPrice - 30;
    }
    return originPrice * 0.8;
  },
  back(originPrice) {
    if (originPrice >= 200) {
      return originPrice - 50;
    }
    return originPrice;
  },
  fresh(originPrice) {
    return originPrice * 0.5;
  },
};
```

通过 tag 定位 method

```jsx
function askPrice(tag, originPrice) {
	return priceProcessor[tag](originPrice)
}
```

对于新的映射关系，只需要为 `priceProcessor` 添加新的方法就可以了

```jsx
priceProcessor.newUser = function (originPrice) {
  if (originPrice >= 100) {
    return originPrice - 50;
  }
  return originPrice;
}
```

完美符合开闭原则！