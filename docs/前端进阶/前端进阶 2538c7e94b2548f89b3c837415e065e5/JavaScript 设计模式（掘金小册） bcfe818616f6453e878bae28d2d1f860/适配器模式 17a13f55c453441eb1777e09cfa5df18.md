# 适配器模式

通过创建一个适配器的类或对象，来转换一个类的接口为另一个接口，从而使得不兼容的类可以一起工作。

在处理遗留系统或第三方库时，可以通过适配器兼容不同的接口，使得客户端可以通过只调用一个接口即可兼容新旧接口

业务场景：兼容 `fetch` 与 `Ajax`

```jsx
// 新的接口
class HttpUtils {
  static get(url) {
    return new Promise((resolve, reject) => {
      fetch(url).then(resolve).catch(reject)
    })
  }
  static post(url, data) {
    return new Promise(() => {
      /* ... */
    })
  }
}

// 旧的接口
function Ajax(type, url, data, successCb, faildCb) {
  const xhr = new XMLHttpRequest()

  if (type.toLowerCase() === 'get') {
    /* ... */
  }
  if (type.toLowerCase() === 'post') {
    /* ... */
  }

  xhr.onreadystatechange = () => {
    xhr.readyState === 4 && xhr.status === 200 ? successCb(xhr.responseText) : faildCb(xhr.status)
  }
}

// 适配器，保持跟旧接口参数一致
async function AjaxAdapter(type, url, data, successCb, faildCb) {

  let result

  // 在这里用新接口 HttpUtils 实现旧接口 Ajax 的功能，即可完成旧接口的适配
  type.toLowerCase() === 'get' && (result = await HttpUtils.get(url))
  type.toLowerCase() === 'post' && (result = await HttpUtils.post(url, data))

  result.status === 200 ? successCb(result.data) : faildCb(result.status)
}

// 重写Ajax接口
function Ajax(type, url, data, successCb, faildCb) {
	return AjaxAdapter(type, url, data, successCb, faildCb)
}

// 这样，客户端就不用改变原接口的写法，即可适配新接口

```