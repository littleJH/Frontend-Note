# 代理模式

常见应用场景：事件代理、虚拟代理、缓存代理、保护代理

### 事件代理

借助事件冒泡机制，将子元素的事件统一绑定到父元素上，由父元素对事件进行处理和分发。

### 虚拟代理

主要用于延迟加载（懒加载）或按需加载资源，从而节省资源和性能

延迟加载图片

```jsx
class MyImg {
  constructor(imgNode) {
    // 获取真实DOM
    this.imgNode = imgNode
  }

  // 操作真实 img 的 src 属性
  setSrc(url) {
    this.imgNode.src = url
  }
}

class ProxyImg {
  // 占位图片url
  static loading_url = 'https://example.com/loading-image.jpg'

  constructor(myImg) {
    this.myImg = myImg
  }

  // 操作虚拟 img 的src属性，完成图片资源的加载
  setSrc(url) {
    // 为真实 img 添加占位图
    this.myImg.setSrc(this.loading_url)
    // 新建一个虚拟 img
    const vImg = new Image()
    // 为虚拟 img 添加 onload 事件
    vImg.onload = () => {
      // 加载完成后设置真实 img 的 src
      this.myImg.setSrc(url)
    }
    // 加载图片资源
    vImg.src = url
  }
}

const imgEl = document.querySelector('#myImg')
const myImg = new MyImg(imgEl)
const proxyIMg = new ProxyImg(myImg)

// 在需要的时候加载图片资源
proxyIMg.setSrc('xxx')

```

### 缓存代理

实现方式：闭包

```jsx
const proxyCache = function (caculateFn) {
	// 用 Map 缓存计算结果
  const resultCache = new Map()
  return function () {
	  // 函数体字符串序列+参数序列，作为 map 的键
    const key = `${JSON.stringify(caculateFn)}_${Array.prototype.join.apply(arguments)}`
    if (!resultCache.has(key)) {
      console.log('计算')
      resultCache.set(key, caculateFn.apply(this, arguments))
    }
    return resultCache.get(key)
  }
}

const addCache = proxyCache((a, b) => a + b)

console.log("🚀 ~ addCache(1, 2):", addCache(1, 2))
console.log("🚀 ~ addCache(1, 2):", addCache(1, 2))
```

### 保护代理

典型应用：ES6 的 proxy