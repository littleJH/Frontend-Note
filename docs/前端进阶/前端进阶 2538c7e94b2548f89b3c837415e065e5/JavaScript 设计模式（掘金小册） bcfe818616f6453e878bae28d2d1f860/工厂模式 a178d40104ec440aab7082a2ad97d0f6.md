# 工厂模式

铺垫知识：[构造器模式](%E6%9E%84%E9%80%A0%E5%99%A8%E6%A8%A1%E5%BC%8F%2077b4f5aac6174426b6e20e0daacc4394.md)

构造器模式是：从手动创建实例，到通过构造函数抽象出每个对象的变与不变

那么工厂模式就是：抽象每个**构造函数之间的变与不变**

## 简单工厂

将**创建对象的过程**单独封装

未使用工厂模式：

```jsx
function Coder(name , age) {
    this.name = name
    this.age = age
    this.career = 'coder' 
    this.work = ['写代码','写系分', '修Bug']
}
function ProductManager(name, age) {
    this.name = name 
    this.age = age
    this.career = 'product manager'
    this.work = ['订会议室', '写PRD', '催更']
}

function Factory(name, age, career) {
    switch(career) {
        case 'coder':
            return new Coder(name, age) 
            break
        case 'product manager':
            return new ProductManager(name, age)
            break
        ...
}
```

使用简单工厂模式：

```jsx
function User(name , age, career, work) {
    this.name = name
    this.age = age
    this.career = career 
    this.work = work
}

function UserFactory(name, age, career) {
    let work
    switch(career) {
        case 'coder':
            work =  ['写代码','写系分', '修Bug'] 
            break
        case 'product manager':
            work = ['订会议室', '写PRD', '催更']
            break
        case 'boss':
            work = ['喝茶', '看报', '见客户']
        case 'xxx':
            // 其它工种的职责分配
            ...
            
    // 将 new 对象的行为单独封装！
    return new User(name, age, career, work) 
}

```

应用场景：

在写了大量构造函数、调用了大量 new 的情况下