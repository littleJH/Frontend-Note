# 装饰器模式

定义：在不改变原对象的基础上，通过对其进行包装扩展，动态地为对象添加新的行为。

在JavaScript中，装饰器是装饰器模式的典型体现。

### React  HOC

> 高阶组件就是一个函数，接受一个组件作为参数，并返回一个新的组件
> 

### ES7 中的装饰器 `Decorator`

- 类装饰器
    
    ```jsx
    function classDecorator(target) {
    	target.fn = () => 'hhh'
    	return target
    }
    
    @classDecorator
    class Button {
    	
    }
    
    console.log(Button.fn())   // hhh
    ```
    
- 方法装饰器
    - 输出调用日志
        
        ```jsx
        function log(message) {
          return function (target, key, descriptor) {
            const originMethod = descriptor.value
            descriptor.value = function (...args) {
              console.log(`${message}： 方法 ${key} 被调用`)
              return originMethod.call(this, ...args)
            }
            return descriptor
          }
        }
        
        class Button {
          @log('DEBUG')
          onClick() {
            /*...*/
          }
        }
        
        const button = new Button()
        
        button.onClick()   // DEBUG：方法 onClick 被调用
        ```
        
    - 验证参数的方法装饰器
        
        ```jsx
        function validate(types) {
          return function (target, key, descriptor) {
            const originMethod = descriptor.value
        
            descriptor.value = function (...args) {
              if (args.length > 0 && args.every((val) => types.includes(typeof val))) {
                return originMethod.apply(this, args)
              } 
        			else throw new Error('validate failed')
            }
            return descriptor
          }
        }
        
        class MyClass {
        	// 调用属性验证装饰器，并传递可接受的属性的类型数组
        	@validate(['string', 'number'])
        	myFn (arg1, arg2) {}
        }
        ```
        
- 属性装饰器
    - 只读属性装饰器
        
        ```jsx
        function readonly (target, key) {
          Object.defineProperty(target, key, {
        		writable: false,
        		enumerable: true,
        		configurable: true,
        		value: target[key]
        	})
        }
        
        class Button {
        	@readonly
        	name = 'myButton'
        }
        ```
        
    - 属性验证装饰器
        
        ```jsx
        function validate (validateFn) {
        	return function(target, key) {
        		Object.defineProperty(target, key, {
        			set (newVal) {
        				// 验证新值
        				if(!validateFn(newVal)) {
        					throw new Error('new value validate failed')
        				}
        				target[key] = newVal
        			}
        		})
        	}
        }
        
        class MyClass {
        	// 调用属性验证装饰器，并传递验证函数
        	@validate((str) => typeof str === 'string' && str.length > 0)
        	myProperty = 'hhh'
        }
        ```