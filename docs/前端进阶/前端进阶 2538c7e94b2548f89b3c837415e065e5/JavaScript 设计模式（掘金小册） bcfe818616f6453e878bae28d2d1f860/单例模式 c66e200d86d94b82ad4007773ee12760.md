# 单例模式

保证一个类只有一个实例！

实现方式

1. 将判断逻辑写成一个静态方法
    
    ```jsx
    class SingleDog {
    	static getInstance () {
    		if(SingleDog.instance) {
    		// 如果实例存在，直接返回实例
    			return SingleDog.instance
    		} else {
    		// 不存在，new，动态添加 instance 静态属性
    			SingleDog.instance = new SingleDog()
    		}
    		return SingleDog.instance
    	}
    }
    ```
    
2. 闭包
    
    ```jsx
    // 通过 立即调用表达式 模拟 私有变量，即 instance
    SingleDog.getInstance = (function () {
    	let instance = null
    	return function () {
    		if(!instance) {
    			instance = new SingleDog()
    		} else {
    			return instance
    		}
    	}
    })()
    
    const s1 = SingleDog.getInstance();
    const s2 = SingleDog.getInstance();
    
    s1 === s2    // true
    ```
    

## Pinia 中的单例模式

### 作用

使得在整个 Vue 应用中，所有组件都能访问到同一个且唯一的 Store 实例，保证了数据的一致性和一致的状态管理，降低了程序的复杂性。

### 如何实现

```jsx
// 全局symbol，保证 pinia 实例的唯一性
export const piniaSymbol = (
  __DEV__ ? Symbol('pinia') : /* istanbul ignore next */ Symbol()
) as InjectionKey<Pinia>

export function createPinia(): Pinia {

  const pinia: Pinia = markRaw({
    install(app: App) {

      setActivePinia(pinia)
      if (!isVue2) {
        pinia._a = app
        // 全局注入pinia
        // privide 的第一个参数 piniaSymbol 具有唯一性，因此能保证注入 pinia 的唯一性
        app.provide(piniaSymbol, pinia)
        app.config.globalProperties.$pinia = pinia
      }
    }
    
  return pinia
}

```

```jsx
// 创建 Vue 实例
const app = createApp()

// 创建 store
const store = createPinia()

// 将 store 注册到 vue 实例上
app.use(store)
```

### 单例的局限性

- store 的唯一性是相对一个 Vue 一个应用的，而不是全局的
- 在同一个页面中，可能存在多个 Vue 应用，每个应用都可以拥有自己的 store 实例
- 在不同的 Vue 应用中，当需要共享同一个 store 时，仍然需要在全局范围内使用单例模式来确保 store 的唯一性。

### 面试真题

思路：记住 `getInstance` 方法，记住 `instance` 变量，记住 **静态方法** 和 **闭包**

实现一个全局模态框

方法 1 ：闭包

```jsx
    const Modal = (function () {
	    // 私有变量，用来存储单例实例
      let modal = null
      return {
	      // 获取 modal 实例的方法
        getInstance() {
          if (!modal) {
            modal = document.createElement('div')
            modal.innerHTML = 'modal'
            modal.id = 'modal'
            modal.style.display = 'none'
            document.body.appendChild(modal)
          }
          return modal
        },
        
        show() {
          const modal = this.getInstance()
          modal.style.display = 'block'
        },
        hide() {
          const modal = this.getInstance()
          modal.style.display = 'none'
        }
      }
    })()
    
    const instance = Modal.getInstance()

    document.getElementById('open').addEventListener('click', () => {
      instance.show()
    })

    document.getElementById('close').addEventListener('click', () => {
      instance.hide()
    })
```

方法 2：类+静态属性+静态方法

正常情况下：通过静态方法 `Modal.getInstance()` 获取实例，可以保证实例的唯一性

容错处理：保留 `constructor` 中的实例检查，防止 `new Modal()` 创建多个实例

```jsx
class Modal {
			// 静态属性，用于存储单例实例
      static instance = null
			// 静态方法，用于获取单例实例
      static getInstance() {
        if (!Modal.instance) {
          Modal.instance = new Modal()
        }
        return Modal.instance
      }
      
			// 构造函数
      constructor() {
        if (!Modal.instance) {
          const modal = document.createElement('div')
          modal.innerHTML = 'modal'
          modal.id = 'modal'
          modal.style.display = 'none'
          document.body.appendChild(modal)
          this.modal = modal
          // 将当前实例赋值给 instance 静态属性
          Modal.instance = this
        }
				// 返回单例实例
        return Modal.instance
      }

      show() {
        this.modal.style.display = 'block'
      }
      hide() {
        this.modal.style.display = 'none'
      }
    }

    const instance = Modal.getInstance()

    document.getElementById('open').addEventListener('click', () => {
      instance.show()
    })

    document.getElementById('close').addEventListener('click', () => {
      instance.hide()
    })
```

[全局模态框](%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%20c66e200d86d94b82ad4007773ee12760/Untitled-1.html)